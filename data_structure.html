<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Karla:wght@200&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="indexpage.css">
        
   
        
        
    <title> Data Structure</title>
</head>

<body>
  <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
  <nav class="navbar">
    <a href="index.html" target="_self" >
    <div class="logo">
      <span >
  
          <img src="finger.png" class="finbtn"/>

        </span>
        &nbsp;
    <span class="logoname">
   <h1></b>CodeFinger</b></h1>
</span>
    </div></a>
    <b>
    <div class="navelement">
      <a href="c_language.html">C Language</a>
      <a href="data_structure.html">Data Structure</a>
      <a href="feedback.html">Feedback</a>
      <a href="table.html">Time complexity</a>
    </b>
  </div>
    <div class="login-container"><!--buttons for Login/Sign Up-->
      <button type="submit">Login/Sign Up</button>
  </div> 


   <div class="linksection">
  <div class="linksection" id="linksec">
      <a href="#section1" class="link">Linear search algorithm</a>
      <a href="#section2" class="link">Binary search algorithm</a>
      <a href="#section3" class="link">Bubble sort algorithm</a>
      <a href="#section4" class="link">Selection sort algorithm</a>
      <a href="#section5" class="link">Insertion sort algorithm</a>
      <a href="#section6" class="link">Merge sort algorithm</a>
      <a href="#section7" class="link">Quick sort algorithm</a>
      <a href="#section8" class="link">Counting sort algorithm</a>
      <a href="#section9" class="link">Bucket sort algorithm</a>
      <a href="#section10" class="link">Heap sort algorithm</a>
      <a href="#section11" class="link">Implementation of stack</a>
      <a href="#section12" class="link">Implementation of queue</a>
      <a href="#section13" class="link">Implementaion of linked list</a>
      
  </div>
  </div>
  <div class="navelemrnt2">
    <div class="navelement2">
                   
<a href="c_language.html" class="abc" title="C Language">C Lang</a><br><hr>
<a href="data_structure.html" class="abc"  title="Data Structure">Data Str</a><br><hr>
<a href="feedback.html" class="abc"  title="Feed Back">FDBK</a><br><hr>
<a href="table.html" class="abc"  title="Time Complexity">Complexity</a><br>
</div>
</div>

</nav>
  
    <!--<nav>
        <span class="logo"><img src="copy.png" alt=""></span>
        <div class="content center">
             Data Structure In C Cheatsheet
        </div>
        </nav>-->

<main>  
 

        <div class="container1">
        <ol>
            <li><h4>SEARCHING TECHNIQUE</h4><b id="section1">Linear search algorithm</b>
              <p class="detail">Lorem ipsum dolor sit amet consectetur adipisicing elit. Tenetur dolorum rem repellat aut quidem tempora porro nisi ipsa debitis, fuga quos id eaque perspiciatis at asperiores vel, dignissimos quod enim!</p>
                <pre class="panda"><code id="content-copy1">
// Linear Search in C

#include &lt;stdio.h&gt;

int search(int array[], int n, int x) {
  
  // Going through array sequencially
  for (int i = 0; i &lt; n; i++)
    if (array[i] == x)
      return i;
  return -1;
}

int main() {
  int array[] = {2, 4, 0, 1, 9};
  int x = 1;
  int n = sizeof(array) / sizeof(array[0]);

  int result = search(array, n, x);

  (result == -1) ? printf("Element not found") : printf("Element found at index: %d", result);
}
</code>
<button  id="btn-copy1" onclick="copy('content-copy1')" class="btn" >copy</button> 
</pre>
    </li>
     
    <b id="section2">Binary search algorithm</b>
    <p class="detail">Lorem ipsum dolor, sit amet consectetur adipisicing elit. Totam ipsa enim repellendus? Cumque perspiciatis impedit suscipit necessitatibus repellendus laudantium quia quos sequi laboriosam, hic obcaecati modi sed amet a totam!</p> 
        <pre class="panda"><code id="content-copy2">
// Binary Search in C

#include &lt;stdio.h&gt;
            
    int binarySearch(int array[], int x, int low, int high) {
    // Repeat until the pointers low and high meet each other
              
    while (low &lt= high) {
    int mid = low + (high - low) / 2;
            
    if (array[mid] == x)
        return mid;
            
    if (array[mid] 7lt; x)
        low = mid + 1;
            
     else
         high = mid - 1;
    }
            
    return -1;
    }
            
    int main(void) {
    int array[] = {3, 4, 5, 6, 7, 8, 9};
    int n = sizeof(array) / sizeof(array[0]);
    int x = 4;
    int result = binarySearch(array, x, 0, n - 1);
        if (result == -1)
                printf("Not found");
         else
                printf("Element is found at index %d", result);
         return 0;
    }
   
</code>
 <button  id="btn-copy2" onclick="copy('content-copy2')" class="btn" >copy</button> 
</pre>
</li>



<li><h4>SORTING TECHNIQUE</h4><b id="section3">Bubble sort algorithm</b>
  <p class="detail">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Iusto esse totam voluptatum ex consequuntur cupiditate commodi ullam nam. Beatae maiores ad tempore possimus magni fuga animi inventore blanditiis iure atque?</p>
    <pre class="panda"><code id="content-copy3">
// Bubble sort in C

#include &lt;stdio.h&gt;
        
// perform the bubble sort
void bubbleSort(int array[], int size) {
        
// loop to access each array element
    for (int step = 0; step &lt; size - 1; ++step) {
              
    // loop to compare array elements
    for (int i = 0; i &lt; size - step - 1; ++i) {
              
    // compare two adjacent elements
    // change > to &lt; to sort in descending order
        if (array[i] > array[i + 1]) {
                
        // swapping occurs if elements
        // are not in the intended order
        int temp = array[i];
        array[i] = array[i + 1];
         array[i + 1] = temp;
         }
       }
    }
}
        
    // print array
        void printArray(int array[], int size) {
          for (int i = 0; i &lt; size; ++i) {
            printf("%d  ", array[i]);
          }
          printf("\n");
        }
        
        int main() {
          int data[] = {-2, 45, 0, 11, -9};
          
          // find the array's length
          int size = sizeof(data) / sizeof(data[0]);
        
          bubbleSort(data, size);
          
          printf("Sorted Array in Ascending Order:\n");
          printArray(data, size);
        }

</code>
<button  id="btn-copy3" onclick="copy('content-copy4')" class="btn" >copy</button> 
</pre>
</li>


<li><b id="section4">Selection sort algorithm</b>
  <p class="detail">Lorem ipsum dolor, sit amet consectetur adipisicing elit. Obcaecati, quaerat! Nam, ex excepturi repudiandae quas suscipit cum laborum. Doloremque quibusdam quod modi placeat id quasi ea dolorem nostrum officiis quo.</p>
    <pre class="panda"><code id="content-copy4">
// Selection sort in C

 #include &lt;stdio.h&gt;
        
// function to swap the the position of two elements
    void swap(int *a, int *b) {
        int temp = *a;
        *a = *b;
         *b = temp;
    }
        
     void selectionSort(int array[], int size) {
        for (int step = 0; step &lt; size - 1; step++) {
         int min_idx = step;
        for (int i = step + 1; i &lt; size; i++) {
        
    // To sort in descending order, change > to &lt in this line.
    // Select the minimum element in each loop.
    if (array[i] &lt; array[min_idx])
        min_idx = i;
         }
        
        // put min at the correct position
        swap(&array[min_idx], &array[step]);
          }
        }
        
        // function to print an array
        void printArray(int array[], int size) {
          for (int i = 0; i 7lt; size; ++i) {
            printf("%d  ", array[i]);
          }
          printf("\n");
        }
        
        // driver code
        int main() {
          int data[] = {20, 12, 10, 15, 2};
          int size = sizeof(data) / sizeof(data[0]);
          selectionSort(data, size);
          printf("Sorted array in Acsending Order:\n");
          printArray(data, size);
        }

</code>
<button  id="btn-copy4" onclick="copy('content-copy4')" class="btn" >copy</button> 
</pre>
</li>


       <li><b id="section5">Insertion sort algorithm</b>
        <p class="detail">Lorem ipsum dolor sit, amet consectetur adipisicing elit. Delectus doloremque consectetur adipisci voluptatum, asperiores at modi veniam voluptatibus inventore illo iste cumque a expedita perferendis, necessitatibus blanditiis autem iusto sint?</p>
<pre class="panda"><code id="content-copy5">
 // Insertion sort in C

 #include &lt;stdio.h&gt;
                    
// Function to print an array
    void printArray(int array[], int size) {
    for (int i = 0; i &lt; size; i++) {
            printf("%d ", array[i]);
          }
         printf("\n");
        }
                    
    void insertionSort(int array[], int size) {
    for (int step = 1; step &lt; size; step++) {
        int key = array[step];
        int j = step - 1;
                    
        // Compare key with each element on the left of it until an element smaller than
        // it is found.
        // For descending order, change key<array[j] to key>array[j].
         while (key &lt; array[j] && j >= 0) {
                array[j + 1] = array[j];
                  --j;
             }
            array[j + 1] = key;
             }
         }
                    
    // Driver code
        int main()
         {
        int data[] = {9, 5, 1, 4, 3};
        int size = sizeof(data) / sizeof(data[0]);
        insertionSort(data, size);
         printf("Sorted array in ascending order:\n");
         printArray(data, size);
        }
</code>
<button  id="btn-copy5" onclick="copy('content-copy5')" class="btn" >copy</button> 
</pre>
</li>



       <li><b id="section6">Merge sort algorithm</b>
        <p class="detail">Lorem ipsum dolor sit amet consectetur adipisicing elit. Vero, aut laboriosam veniam rerum atque optio odit temporibus quaerat at rem accusantium et ea maxime nesciunt sequi repellat obcaecati cupiditate accusamus.</p>
  <pre class="panda"><code id="content-copy6">
// Merge sort in C

 #include &lt;stdio.h&gt;
                
// Merge two subarrays L and M into arr
void merge(int arr[], int p, int q, int r) {
                
    // Create L ← A[p..q] and M ← A[q+1..r]
     int n1 = q - p + 1;
    int n2 = r - q;
                
    int L[n1], M[n2];
                
    for (int i = 0; i&lt; n1; i++)
    L[i] = arr[p + i];
    for (int j = 0; j &lt; n2; j++)
    M[j] = arr[q + 1 + j];
                
    // Maintain current index of sub-arrays and main array
        int i, j, k;
        i = 0;
        j = 0;
        k = p;
                
    // Until we reach either end of either L or M, pick larger among
    // elements L and M and place them in the correct position at A[p..r]
                  
    while (i &lt; n1 && j &lt; n2) {
    if (L[i] &lt;= M[j]) {
     arr[k] = L[i];
         i++;
        } 
        else {
         arr[k] = M[j];
        j++;
        }
        k++;
        }
                
        // When we run out of elements in either L or M,
        // pick up the remaining elements and put in A[p..r]
        while (i &lt; n1) {
            arr[k] = L[i];
            i++;
            k++;
            }
                
        while (j &lt; n2) {
            arr[k] = M[j];
            j++;
             k++;
            }
        }
                
    // Divide the array into two subarrays, sort them and merge them
    void mergeSort(int arr[], int l, int r) {
    if (l &lt; r) {
                
    // m is the point where the array is divided into two subarrays
        int m = l + (r - l) / 2;
                
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
                
        // Merge the sorted subarrays
        merge(arr, l, m, r);
         }
        }
                
        // Print the array
        void printArray(int arr[], int size) {
        for (int i = 0; i &lt; size; i++)
             printf("%d ", arr[i]);
            printf("\n");
        }
                
        // Driver program
        int main() {
        int arr[] = {6, 5, 12, 10, 9, 1};
         int size = sizeof(arr) / sizeof(arr[0]);
                
        mergeSort(arr, 0, size - 1);
                
        printf("Sorted array: \n");
         printArray(arr, size);
   }

</code>
<button  id="btn-copy6" onclick="copy('content-copy7')" class="btn" >copy</button> 
</pre>
</li>

       
        <li><b id="section7">Quick sort algorithm</b>
          <p class="detail">Lorem ipsum dolor sit, amet consectetur adipisicing elit. Nisi quibusdam rerum itaque non beatae, tempore maiores, quas accusantium assumenda, facere officiis earum facilis iste molestiae exercitationem expedita suscipit recusandae est.</p>
                 <pre class="panda"><code id="content-copy7">
// Quick sort in C

#include &lt;stdio.h&gt;
        
// function to swap elements
void swap(int *a, int *b) {
     int t = *a;
    *a = *b;
    *b = t;
    }
        
        // function to find the partition position
        int partition(int array[], int low, int high) {
          
          // select the rightmost element as pivot
          int pivot = array[high];
          
          // pointer for greater element
          int i = (low - 1);
        
          // traverse each element of the array
          // compare them with the pivot
          for (int j = low; j &lt; high; j++) {
            if (array[j] &lt;= pivot) {
                
              // if element smaller than pivot is found
              // swap it with the greater element pointed by i
              i++;
              
              // swap element at i with element at j
              swap(&array[i], &array[j]);
            }
          }
        
          // swap the pivot element with the greater element at i
          swap(&array[i + 1], &array[high]);
          
          // return the partition point
          return (i + 1);
        }
        
        void quickSort(int array[], int low, int high) {
          if (low &lt; high) {
            
            // find the pivot element such that
            // elements smaller than pivot are on left of pivot
            // elements greater than pivot are on right of pivot
            int pi = partition(array, low, high);
            
            // recursive call on the left of pivot
            quickSort(array, low, pi - 1);
            
            // recursive call on the right of pivot
            quickSort(array, pi + 1, high);
          }
        }
        
        // function to print array elements
        void printArray(int array[], int size) {
          for (int i = 0; i &lt; size; ++i) {
            printf("%d  ", array[i]);
          }
          printf("\n");
        }
        
        // main function
        int main() {
          int data[] = {8, 7, 2, 1, 0, 9, 6};
          
          int n = sizeof(data) / sizeof(data[0]);
          
          printf("Unsorted Array\n");
          printArray(data, n);
          
          // perform quicksort on data
          quickSort(data, 0, n - 1);
          
          printf("Sorted array in ascending order: \n");
          printArray(data, n);
        }
</code>
<button  id="btn-copy7" onclick="copy('content-copy7')" class="btn" >copy</button> 
</pre>
</li>


        <li><b id="section8">Counting sort algorithm</b>
          <p class="detail">Lorem ipsum dolor, sit amet consectetur adipisicing elit. Pariatur officiis sequi eligendi libero vel, velit hic quisquam perferendis nam ipsam molestias illum molestiae eum cumque et, unde deleniti. Quidem, qui.</p>
                 <pre class="panda"><code id="content-copy8">
 // Counting sort in C programming

#include &lt;stdio.h&gt;

void countingSort(int array[], int size) {
int output[10];

            // Find the largest element of the array
            int max = array[0];
            for (int i = 1; i & size; i++) {
                if (array[i] > max)
                max = array[i];
            }

            // The size of count must be at least (max+1) but
            // we cannot declare it as int count(max+1) in C as
            // it does not support dynamic memory allocation.
            // So, its size is provided statically.
            int count[10];

            // Initialize count array with all zeros.
            for (int i = 0; i &lt;= max; ++i) {
                count[i] = 0;
            }

            // Store the count of each element
            for (int i = 0; i &lt; size; i++) {
                count[array[i]]++;
            }

            // Store the cummulative count of each array
            for (int i = 1; i &lt;= max; i++) {
                count[i] += count[i - 1];
            }

            // Find the index of each element of the original array in count array, and
            // place the elements in output array
            for (int i = size - 1; i >= 0; i--) {
                output[count[array[i]] - 1] = array[i];
                count[array[i]]--;
            }

            // Copy the sorted elements into original array
            for (int i = 0; i &lt; size; i++) {
                array[i] = output[i];
            }
            }

            // Function to print an array
            void printArray(int array[], int size) {
            for (int i = 0; i &lt; size; ++i) {
                printf("%d  ", array[i]);
            }
            printf("\n");
            }

            // Driver code
            int main() {
            int array[] = {4, 2, 2, 8, 3, 3, 1};
            int n = sizeof(array) / sizeof(array[0]);
            countingSort(array, n);
            printArray(array, n);
}   
</code>
<button  id="btn-copy8" onclick="copy('content-copy8')" class="btn" >copy</button> 
</pre>
</li>


<li><b id="section9">Bucket sort algorithm</b>
  <p class="detail">Lorem ipsum, dolor sit amet consectetur adipisicing elit. Numquam quae sequi corporis sunt temporibus. Vel excepturi cupiditate facere labore, nostrum aliquid reprehenderit ipsam eveniet est, beatae minima! Adipisci, officiis pariatur.</p>
    <pre class="panda"><code id="content-copy9">
// Bucket sort in C

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
        
#define NARRAY 7   // Array size
#define NBUCKET 6  // Number of buckets
#define INTERVAL 10  // Each bucket capacity
        
        struct Node {
          int data;
          struct Node *next;
        };
        
        void BucketSort(int arr[]);
        struct Node *InsertionSort(struct Node *list);
        void print(int arr[]);
        void printBuckets(struct Node *list);
        int getBucketIndex(int value);
        
        // Sorting function
        void BucketSort(int arr[]) {
          int i, j;
          struct Node **buckets;
        
          // Create buckets and allocate memory size
          buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);
        
          // Initialize empty buckets
          for (i = 0; i &lt; NBUCKET; ++i) {
            buckets[i] = NULL;
          }
        
          // Fill the buckets with respective elements
          for (i = 0; i &lt; NARRAY; ++i) {
            struct Node *current;
            int pos = getBucketIndex(arr[i]);
            current = (struct Node *)malloc(sizeof(struct Node));
            current->data = arr[i];
            current->next = buckets[pos];
            buckets[pos] = current;
          }
        
          // Print the buckets along with their elements
          for (i = 0; i &lt; NBUCKET; i++) {
            printf("Bucket[%d]: ", i);
            printBuckets(buckets[i]);
            printf("\n");
          }
        
          // Sort the elements of each bucket
          for (i = 0; i &lt; NBUCKET; ++i) {
            buckets[i] = InsertionSort(buckets[i]);
          }
        
          printf("-------------\n");
          printf("Bucktets after sorting\n");
          for (i = 0; i &lt; NBUCKET; i++) {
            printf("Bucket[%d]: ", i);
            printBuckets(buckets[i]);
            printf("\n");
          }
        
          // Put sorted elements on arr
          for (j = 0, i = 0; i &lt; NBUCKET; ++i) {
            struct Node *node;
            node = buckets[i];
            while (node) {
              arr[j++] = node->data;
              node = node->next;
            }
          }
        
          return;
        }
        
        // Function to sort the elements of each bucket
        struct Node *InsertionSort(struct Node *list) {
          struct Node *k, *nodeList;
          if (list == 0 || list->next == 0) {
            return list;
          }
        
          nodeList = list;
          k = list->next;
          nodeList->next = 0;
          while (k != 0) {
            struct Node *ptr;
            if (nodeList->data > k->data) {
              struct Node *tmp;
              tmp = k;
              k = k->next;
              tmp->next = nodeList;
              nodeList = tmp;
              continue;
            }
        
            for (ptr = nodeList; ptr->next != 0; ptr = ptr->next) {
              if (ptr->next->data > k->data)
                break;
            }
        
            if (ptr->next != 0) {
              struct Node *tmp;
              tmp = k;
              k = k->next;
              tmp->next = ptr->next;
              ptr->next = tmp;
              continue;
            } else {
              ptr->next = k;
              k = k->next;
              ptr->next->next = 0;
              continue;
            }
          }
          return nodeList;
        }
        
        int getBucketIndex(int value) {
          return value / INTERVAL;
        }
        
        void print(int ar[]) {
          int i;
          for (i = 0; i &lt; NARRAY; ++i) {
            printf("%d ", ar[i]);
          }
          printf("\n");
        }
        
        // Print buckets
        void printBuckets(struct Node *list) {
          struct Node *cur = list;
          while (cur) {
            printf("%d ", cur->data);
            cur = cur->next;
          }
        }
        
        // Driver code
        int main(void) {
          int array[NARRAY] = {42, 32, 33, 52, 37, 47, 51};
        
          printf("Initial array: ");
          print(array);
          printf("-------------\n");
        
          BucketSort(array);
          printf("-------------\n");
          printf("Sorted array: ");
          print(array);
          return 0;
}
</code>
<button  id="btn-copy9" onclick="copy('content-copy9')" class="btn" >copy</button> 
</pre>
</li>

            <li><b id="section10">Heap sort algorithm</b>
              <p class="detail">Lorem ipsum, dolor sit amet consectetur adipisicing elit. Dolor voluptatum autem cum quasi dicta molestias laudantium non est blanditiis, placeat, unde expedita, modi dolore repellat cumque. Dicta eius dignissimos voluptatem?</p>
                     <pre class="panda"><code id="content-copy10">      
// Heap Sort in C

 #include &lt;stdio.h&gt;
        
// Function to swap the the position of two elements
        void swap(int *a, int *b) {
            int temp = *a;
            *a = *b;
            *b = temp;
        }
        
        void heapify(int arr[], int n, int i) {
            // Find largest among root, left child and right child
            int largest = i;
            int left = 2 * i + 1;
            int right = 2 * i + 2;
        
            if (left &lt; n && arr[left] > arr[largest])
            largest = left;
        
            if (right &lt; n && arr[right] > arr[largest])
            largest = right;
        
            // Swap and continue heapifying if root is not largest
            if (largest != i) {
            swap(&arr[i], &arr[largest]);
            heapify(arr, n, largest);
            }
        }
        
        // Main function to do heap sort
        void heapSort(int arr[], int n) {
            // Build max heap
            for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);
        
            // Heap sort
            for (int i = n - 1; i >= 0; i--) {
            swap(&arr[0], &arr[i]);
        
            // Heapify root element to get highest element at root again
            heapify(arr, i, 0);
            }
        }
        
        // Print an array
        void printArray(int arr[], int n) {
            for (int i = 0; i &lt; n; ++i)
            printf("%d ", arr[i]);
            printf("\n");
        }
        
        // Driver code
        int main() {
            int arr[] = {1, 12, 9, 5, 6, 10};
            int n = sizeof(arr) / sizeof(arr[0]);
        
            heapSort(arr, n);
        
            printf("Sorted array is \n");
            printArray(arr, n);
    }
</code>
<button  id="btn-copy10" onclick="copy('content-copy10')" class="btn" >copy</button> 
</pre>
</li>



         <li><h4>STACK IN DATA STRUCTURE</h4><b id="section11">implementation of stack</b>
          <p class="detail">Lorem ipsum dolor sit amet consectetur adipisicing elit. Mollitia porro quisquam rerum dignissimos molestias. Nihil voluptate adipisci atque sapiente officiis nam magnam, mollitia deserunt incidunt doloremque repellat aspernatur consectetur dolorem?</p>
                 <pre class="panda"><code id="content-copy11">
// Stack implementation in C

 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
                    
 #define MAX 10
                    
int count = 0;
                    
         // Creating a stack
         struct stack {
         int items[MAX];
         int top;
             };
         typedef struct stack st;
                    
         void createEmptyStack(st *s) {
         s->top = -1;
             }
                    
        // Check if the stack is full
        int isfull(st *s) {
        if (s->top == MAX - 1)
            return 1;
         else
            return 0;
         }
                    
        // Check if the stack is empty
        int isempty(st *s) {
        if (s->top == -1)
         return 1;
         else
        return 0;
        }
                    
        // Add elements into stack
        void push(st *s, int newitem) {
        if (isfull(s)) {
        printf("STACK FULL");
         }
          else {
             s->top++;
             s->items[s->top] = newitem;
             }
            count++;
        }
                    
        // Remove element from stack
        void pop(st *s) {
        if (isempty(s)) {
         printf("\n STACK EMPTY \n");
        }
         else {
            printf("Item popped= %d", s->items[s->top]);
            s->top--;
             }
            count--;
             printf("\n");
             }
                    
            // Print elements of stack
            void printStack(st *s) {
             printf("Stack: ");
                 for (int i = 0; i &lt; count; i++) {
                printf("%d ", s->items[i]);
                }
                printf("\n");
                }
                    
         // Driver code
            int main() {
            int ch;
            st *s = (st *)malloc(sizeof(st));
                    
                createEmptyStack(s);
                    
                 push(s, 1);
                 push(s, 2);
                 push(s, 3);
                 push(s, 4);
                    
                 printStack(s);
                    
                 pop(s);
                    
                printf("\nAfter popping out\n");
                printStack(s);
        }
                    
</code>
<button  id="btn-copy11" onclick="copy('content-copy11')" class="btn" >copy</button> 
</pre>
    </li> 
    


    <li><h4>QUEUE IN DATA STRUCTURE</h4><b id="section12">implementation of queue </b>
      <p class="detail">Lorem ipsum dolor sit, amet consectetur adipisicing elit. Eveniet nesciunt quidem eos, veritatis repudiandae harum quasi voluptate vero. Nihil odio eum deleniti, labore omnis error quidem possimus dolorum architecto explicabo.</p>
        <pre class="panda"><code id="content-copy12">
// Queue implementation in C

#include &lt;stdio.h&gt;
#define SIZE 5

void enQueue(int);
void deQueue();
void display();

int items[SIZE], front = -1, rear = -1;

int main() {
  //deQueue is not possible on empty queue
  deQueue();

  //enQueue 5 elements
  enQueue(1);
  enQueue(2);
  enQueue(3);
  enQueue(4);
  enQueue(5);

  // 6th element can't be added to because the queue is full
  enQueue(6);

  display();

  //deQueue removes element entered first i.e. 1
  deQueue();

  //Now we have just 4 elements
  display();

  return 0;
}

void enQueue(int value) {
  if (rear == SIZE - 1)
    printf("\nQueue is Full!!");
  else {
    if (front == -1)
      front = 0;
    rear++;
    items[rear] = value;
    printf("\nInserted -> %d", value);
  }
}

void deQueue() {
  if (front == -1)
    printf("\nQueue is Empty!!");
  else {
    printf("\nDeleted : %d", items[front]);
    front++;
    if (front > rear)
      front = rear = -1;
  }
}

// Function to print the queue
void display() {
  if (rear == -1)
    printf("\nQueue is Empty!!!");
  else {
    int i;
    printf("\nQueue elements are:\n");
    for (i = front; i &lt;= rear; i++)
      printf("%d  ", items[i]);
  }
  printf("\n");
}
           
</code>
<button  id="btn-copy12" onclick="copy('content-copy12')" class="btn" >copy</button> </pre>
</li> 

 
 
<li><h4>LINKED LIST IN DATA STRUCTURE</h4><b id="section13">Implementaion of linked list</b>
  <p class="detail">Lorem ipsum dolor sit, amet consectetur adipisicing elit. Maxime beatae et est itaque aut ipsam, molestias ut, ex, alias explicabo sapiente illo voluptatum dolor dignissimos. A non alias veniam molestias!</p>
    <pre class="panda"><code id="content-copy13">
// Linked list implementation in C

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
        
        // Creating a node
        struct node {
          int value;
          struct node *next;
        };
        
        // print the linked list value
        void printLinkedlist(struct node *p) {
          while (p != NULL) {
            printf("%d ", p->value);
            p = p->next;
          }
        }
        
        int main() {
          // Initialize nodes
          struct node *head;
          struct node *one = NULL;
          struct node *two = NULL;
          struct node *three = NULL;
        
          // Allocate memory
          one = malloc(sizeof(struct node));
          two = malloc(sizeof(struct node));
          three = malloc(sizeof(struct node));
        
          // Assign value values
          one->value = 1;
          two->value = 2;
          three->value = 3;
        
          // Connect nodes
          one->next = two;
          two->next = three;
          three->next = NULL;
        
          // printing node-value
          head = one;
          printLinkedlist(head);
        }
       
</code>
<button  id="btn-copy13" onclick="copy('content-copy13')" class="btn" >copy</button> 
</pre>
</li> 
        </ol>
</div>
</main>

<footer> 
  <p>THIS WEB PAGE CREATED BY ASHWIN CHIMANKAR @2022<br>
  <a href="ashwinchimankar@gmail.com">ashwinchimankar@gmail.com</a></p>
</footer>
 
  </body>
  <script src="maincode.js"></script>
 </html>