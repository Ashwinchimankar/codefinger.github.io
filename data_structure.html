<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Karla:wght@200&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="./css/mainpage.css">
        
   
        
        
    <title> Data Structure</title>
</head>

<body>
  <button onclick="topFunction()" id="myBtn" title="Go to top">Top</button><!--goto top button-->
  <nav class="navbar"><!--nav bar start-->
    <a href="index.html" target="_self" >
    <div class="logo">
      <span >
  
          <img src="./imges/site-logo/finger.png" class="finbtn"/><!--site logo-->

        </span>
        &nbsp;
    <span class="logoname">
   <h1></b>CodeFinger</b></h1><!--site name-->
</span>
    </div></a>
    <b>
    <div class="navelement"><!--page link on navbar-->
      <a href="c_language.html">C Language</a>
      <a href="data_structure.html">Data Structure</a>
      <a href="feedback.html">Feedback</a>
      <a href="table.html">Time complexity</a>
    </b>
  </div>
    <div class="login-container"><!--side bar-->
      <div id="mySidenav" class="sidenav">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
        <a href="c_language.html" >C Language</a>
        <a href="data_structure.html">Data Structure</a>
        <a href="table.html" >Time complexity</a>
        <a href="books.html" >Books</a>
        <a href="feedback.html">Feedback</a>
        <a href="##" >Login</a>
      </div>
      
    
      <span class="hambgr" style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776;</span><!--hamburgur-->
  </div> 


   <div class="linksection"><!--side bar section-->
  <div class="linksection" id="linksec">
      <a href="#section1" class="link">Linear search algorithm</a>
      <a href="#section2" class="link">Binary search algorithm</a>
      <a href="#section3" class="link">Bubble sort algorithm</a>
      <a href="#section4" class="link">Selection sort algorithm</a>
      <a href="#section5" class="link">Insertion sort algorithm</a>
      <a href="#section6" class="link">Merge sort algorithm</a>
      <a href="#section7" class="link">Quick sort algorithm</a>
      <a href="#section8" class="link">Counting sort algorithm</a>
      <a href="#section9" class="link">Bucket sort algorithm</a>
      <a href="#section10" class="link">Heap sort algorithm</a>
      <a href="#section11" class="link">Implementation of stack</a>
      <a href="#section12" class="link">Implementation of queue</a>
      <a href="#section13" class="link">Implementaion of linked list</a>
      
  </div>
  </div>
 

</nav><!--nav bar end -->
  
    <!--<nav>
        <span class="logo"><img src="copy.png" alt=""></span>
        <div class="content center">
             Data Structure In C Cheatsheet
        </div>
        </nav>-->

<main>  
 

        <div class="container1"><!--main container start-->
          <ol>
          <li><h4>SEARCHING TECHNIQUE</h4><b id="section1">Linear search algorithm</b>
              <p class="detail">Linear search is a very simple search algorithm. In this type of search, a sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection.</p>
                <pre class="panda"><code id="content-copy1">
// Linear Search in C

#include &lt;stdio.h&gt;

int search(int array[], int n, int x) {
  
  // Going through array sequencially
  for (int i = 0; i &lt; n; i++)
    if (array[i] == x)
      return i;
  return -1;
}

int main() {
  int array[] = {2, 4, 0, 1, 9};
  int x = 1;
  int n = sizeof(array) / sizeof(array[0]);

  int result = search(array, n, x);

  (result == -1) ? printf("Element not found") : printf("Element found at index: %d", result);
}
</code>
<button  id="btn-copy1" onclick="copy('content-copy1')" class="btn" >copy</button> 
</pre>
    </li>
     
    <b id="section2">Binary search algorithm</b>
    <p class="detail">Binary Search is a search algorithm that is used to find the position of an element (target value ) in a sorted array. The array should be sorted prior to applying a binary search.

      Binary search is also known by these names, logarithmic search, binary chop, half interval search.</p> 
        <pre class="panda"><code id="content-copy2">
// Binary Search in C

#include &lt;stdio.h&gt;
            
    int binarySearch(int array[], int x, int low, int high) {
    // Repeat until the pointers low and high meet each other
              
    while (low &lt= high) {
    int mid = low + (high - low) / 2;
            
    if (array[mid] == x)
        return mid;
            
    if (array[mid] 7lt; x)
        low = mid + 1;
            
     else
         high = mid - 1;
    }
            
    return -1;
    }
            
    int main(void) {
    int array[] = {3, 4, 5, 6, 7, 8, 9};
    int n = sizeof(array) / sizeof(array[0]);
    int x = 4;
    int result = binarySearch(array, x, 0, n - 1);
        if (result == -1)
                printf("Not found");
         else
                printf("Element is found at index %d", result);
         return 0;
    }
   
</code>
 <button  id="btn-copy2" onclick="copy('content-copy2')" class="btn" >copy</button> 
</pre>
</li>



<li><h4>SORTING TECHNIQUE</h4><b id="section3">Bubble sort algorithm</b>
  <p class="detail">Bubble sort in C is a straightforward sorting algorithm that checks and swaps elements if they are not in the intended order. It compares two adjacent elements to find which one is greater or lesser and switches them based on the given condition until the final place of the element is found.</p>
    <pre class="panda"><code id="content-copy3">
// Bubble sort in C

#include &lt;stdio.h&gt;
        
// perform the bubble sort
void bubbleSort(int array[], int size) {
        
// loop to access each array element
    for (int step = 0; step &lt; size - 1; ++step) {
              
    // loop to compare array elements
    for (int i = 0; i &lt; size - step - 1; ++i) {
              
    // compare two adjacent elements
    // change > to &lt; to sort in descending order
        if (array[i] > array[i + 1]) {
                
        // swapping occurs if elements
        // are not in the intended order
        int temp = array[i];
        array[i] = array[i + 1];
         array[i + 1] = temp;
         }
       }
    }
}
        
    // print array
        void printArray(int array[], int size) {
          for (int i = 0; i &lt; size; ++i) {
            printf("%d  ", array[i]);
          }
          printf("\n");
        }
        
        int main() {
          int data[] = {-2, 45, 0, 11, -9};
          
          // find the array's length
          int size = sizeof(data) / sizeof(data[0]);
        
          bubbleSort(data, size);
          
          printf("Sorted Array in Ascending Order:\n");
          printArray(data, size);
        }

</code>
<button  id="btn-copy3" onclick="copy('content-copy4')" class="btn" >copy</button> 
</pre>
</li>


<li><b id="section4">Selection sort algorithm</b>
  <p class="detail">Selection sort is a simple sorting algorithm. This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty and the unsorted part is the entire list.

    The smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundary by one element to the right.</p>
    <pre class="panda"><code id="content-copy4">
// Selection sort in C

 #include &lt;stdio.h&gt;
        
// function to swap the the position of two elements
    void swap(int *a, int *b) {
        int temp = *a;
        *a = *b;
         *b = temp;
    }
        
     void selectionSort(int array[], int size) {
        for (int step = 0; step &lt; size - 1; step++) {
         int min_idx = step;
        for (int i = step + 1; i &lt; size; i++) {
        
    // To sort in descending order, change > to &lt in this line.
    // Select the minimum element in each loop.
    if (array[i] &lt; array[min_idx])
        min_idx = i;
         }
        
        // put min at the correct position
        swap(&array[min_idx], &array[step]);
          }
        }
        
        // function to print an array
        void printArray(int array[], int size) {
          for (int i = 0; i 7lt; size; ++i) {
            printf("%d  ", array[i]);
          }
          printf("\n");
        }
        
        // driver code
        int main() {
          int data[] = {20, 12, 10, 15, 2};
          int size = sizeof(data) / sizeof(data[0]);
          selectionSort(data, size);
          printf("Sorted array in Acsending Order:\n");
          printArray(data, size);
        }

</code>
<button  id="btn-copy4" onclick="copy('content-copy4')" class="btn" >copy</button> 
</pre>
</li>


       <li><b id="section5">Insertion sort algorithm</b>
        <p class="detail">Insertion sort algorithm. Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.</p>
<pre class="panda"><code id="content-copy5">
 // Insertion sort in C

 #include &lt;stdio.h&gt;
                    
// Function to print an array
    void printArray(int array[], int size) {
    for (int i = 0; i &lt; size; i++) {
            printf("%d ", array[i]);
          }
         printf("\n");
        }
                    
    void insertionSort(int array[], int size) {
    for (int step = 1; step &lt; size; step++) {
        int key = array[step];
        int j = step - 1;
                    
        // Compare key with each element on the left of it until an element smaller than
        // it is found.
        // For descending order, change key<array[j] to key>array[j].
         while (key &lt; array[j] && j >= 0) {
                array[j + 1] = array[j];
                  --j;
             }
            array[j + 1] = key;
             }
         }
                    
    // Driver code
        int main()
         {
        int data[] = {9, 5, 1, 4, 3};
        int size = sizeof(data) / sizeof(data[0]);
        insertionSort(data, size);
         printf("Sorted array in ascending order:\n");
         printArray(data, size);
        }
</code>
<button  id="btn-copy5" onclick="copy('content-copy5')" class="btn" >copy</button> 
</pre>
</li>



       <li><b id="section6">Merge sort algorithm</b>
        <p class="detail">Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves. The merge() function is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one.</p>
  <pre class="panda"><code id="content-copy6">
// Merge sort in C

 #include &lt;stdio.h&gt;
                
// Merge two subarrays L and M into arr
void merge(int arr[], int p, int q, int r) {
                
    // Create L ← A[p..q] and M ← A[q+1..r]
     int n1 = q - p + 1;
    int n2 = r - q;
                
    int L[n1], M[n2];
                
    for (int i = 0; i&lt; n1; i++)
    L[i] = arr[p + i];
    for (int j = 0; j &lt; n2; j++)
    M[j] = arr[q + 1 + j];
                
    // Maintain current index of sub-arrays and main array
        int i, j, k;
        i = 0;
        j = 0;
        k = p;
                
    // Until we reach either end of either L or M, pick larger among
    // elements L and M and place them in the correct position at A[p..r]
                  
    while (i &lt; n1 && j &lt; n2) {
    if (L[i] &lt;= M[j]) {
     arr[k] = L[i];
         i++;
        } 
        else {
         arr[k] = M[j];
        j++;
        }
        k++;
        }
                
        // When we run out of elements in either L or M,
        // pick up the remaining elements and put in A[p..r]
        while (i &lt; n1) {
            arr[k] = L[i];
            i++;
            k++;
            }
                
        while (j &lt; n2) {
            arr[k] = M[j];
            j++;
             k++;
            }
        }
                
    // Divide the array into two subarrays, sort them and merge them
    void mergeSort(int arr[], int l, int r) {
    if (l &lt; r) {
                
    // m is the point where the array is divided into two subarrays
        int m = l + (r - l) / 2;
                
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
                
        // Merge the sorted subarrays
        merge(arr, l, m, r);
         }
        }
                
        // Print the array
        void printArray(int arr[], int size) {
        for (int i = 0; i &lt; size; i++)
             printf("%d ", arr[i]);
            printf("\n");
        }
                
        // Driver program
        int main() {
        int arr[] = {6, 5, 12, 10, 9, 1};
         int size = sizeof(arr) / sizeof(arr[0]);
                
        mergeSort(arr, 0, size - 1);
                
        printf("Sorted array: \n");
         printArray(arr, size);
   }

</code>
<button  id="btn-copy6" onclick="copy('content-copy7')" class="btn" >copy</button> 
</pre>
</li>

       
        <li><b id="section7">Quick sort algorithm</b>
          <p class="detail">Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value.

            Quicksort partitions an array and then calls itself recursively twice to sort the two resulting subarrays.</p>
                 <pre class="panda"><code id="content-copy7">
// Quick sort in C

#include &lt;stdio.h&gt;
        
// function to swap elements
void swap(int *a, int *b) {
     int t = *a;
    *a = *b;
    *b = t;
    }
        
        // function to find the partition position
        int partition(int array[], int low, int high) {
          
          // select the rightmost element as pivot
          int pivot = array[high];
          
          // pointer for greater element
          int i = (low - 1);
        
          // traverse each element of the array
          // compare them with the pivot
          for (int j = low; j &lt; high; j++) {
            if (array[j] &lt;= pivot) {
                
              // if element smaller than pivot is found
              // swap it with the greater element pointed by i
              i++;
              
              // swap element at i with element at j
              swap(&array[i], &array[j]);
            }
          }
        
          // swap the pivot element with the greater element at i
          swap(&array[i + 1], &array[high]);
          
          // return the partition point
          return (i + 1);
        }
        
        void quickSort(int array[], int low, int high) {
          if (low &lt; high) {
            
            // find the pivot element such that
            // elements smaller than pivot are on left of pivot
            // elements greater than pivot are on right of pivot
            int pi = partition(array, low, high);
            
            // recursive call on the left of pivot
            quickSort(array, low, pi - 1);
            
            // recursive call on the right of pivot
            quickSort(array, pi + 1, high);
          }
        }
        
        // function to print array elements
        void printArray(int array[], int size) {
          for (int i = 0; i &lt; size; ++i) {
            printf("%d  ", array[i]);
          }
          printf("\n");
        }
        
        // main function
        int main() {
          int data[] = {8, 7, 2, 1, 0, 9, 6};
          
          int n = sizeof(data) / sizeof(data[0]);
          
          printf("Unsorted Array\n");
          printArray(data, n);
          
          // perform quicksort on data
          quickSort(data, 0, n - 1);
          
          printf("Sorted array in ascending order: \n");
          printArray(data, n);
        }
</code>
<button  id="btn-copy7" onclick="copy('content-copy7')" class="btn" >copy</button> 
</pre>
</li>


        <li><b id="section8">Counting sort algorithm</b>
          <p class="detail">Counting sort is a sorting algorithm that sorts the elements of an array by counting the number of occurrences of each unique element in the array. The count is stored in an auxiliary array and the sorting is done by mapping the count as an index of the auxiliary array.</p>
                 <pre class="panda"><code id="content-copy8">
 // Counting sort in C programming

#include &lt;stdio.h&gt;

void countingSort(int array[], int size) {
int output[10];

            // Find the largest element of the array
            int max = array[0];
            for (int i = 1; i & size; i++) {
                if (array[i] > max)
                max = array[i];
            }

            // The size of count must be at least (max+1) but
            // we cannot declare it as int count(max+1) in C as
            // it does not support dynamic memory allocation.
            // So, its size is provided statically.
            int count[10];

            // Initialize count array with all zeros.
            for (int i = 0; i &lt;= max; ++i) {
                count[i] = 0;
            }

            // Store the count of each element
            for (int i = 0; i &lt; size; i++) {
                count[array[i]]++;
            }

            // Store the cummulative count of each array
            for (int i = 1; i &lt;= max; i++) {
                count[i] += count[i - 1];
            }

            // Find the index of each element of the original array in count array, and
            // place the elements in output array
            for (int i = size - 1; i >= 0; i--) {
                output[count[array[i]] - 1] = array[i];
                count[array[i]]--;
            }

            // Copy the sorted elements into original array
            for (int i = 0; i &lt; size; i++) {
                array[i] = output[i];
            }
            }

            // Function to print an array
            void printArray(int array[], int size) {
            for (int i = 0; i &lt; size; ++i) {
                printf("%d  ", array[i]);
            }
            printf("\n");
            }

            // Driver code
            int main() {
            int array[] = {4, 2, 2, 8, 3, 3, 1};
            int n = sizeof(array) / sizeof(array[0]);
            countingSort(array, n);
            printArray(array, n);
}   
</code>
<button  id="btn-copy8" onclick="copy('content-copy8')" class="btn" >copy</button> 
</pre>
</li>


<li><b id="section9">Bucket sort algorithm</b>
  <p class="detail">Bucket Sort is a sorting algorithm that divides the unsorted array elements into several groups called buckets. Each bucket is then sorted by using any of the suitable sorting algorithms or recursively applying the same bucket algorithm.

    Finally, the sorted buckets are combined to form a final sorted array.</p>
    <pre class="panda"><code id="content-copy9">
// Bucket sort in C

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
        
#define NARRAY 7   // Array size
#define NBUCKET 6  // Number of buckets
#define INTERVAL 10  // Each bucket capacity
        
        struct Node {
          int data;
          struct Node *next;
        };
        
        void BucketSort(int arr[]);
        struct Node *InsertionSort(struct Node *list);
        void print(int arr[]);
        void printBuckets(struct Node *list);
        int getBucketIndex(int value);
        
        // Sorting function
        void BucketSort(int arr[]) {
          int i, j;
          struct Node **buckets;
        
          // Create buckets and allocate memory size
          buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);
        
          // Initialize empty buckets
          for (i = 0; i &lt; NBUCKET; ++i) {
            buckets[i] = NULL;
          }
        
          // Fill the buckets with respective elements
          for (i = 0; i &lt; NARRAY; ++i) {
            struct Node *current;
            int pos = getBucketIndex(arr[i]);
            current = (struct Node *)malloc(sizeof(struct Node));
            current->data = arr[i];
            current->next = buckets[pos];
            buckets[pos] = current;
          }
        
          // Print the buckets along with their elements
          for (i = 0; i &lt; NBUCKET; i++) {
            printf("Bucket[%d]: ", i);
            printBuckets(buckets[i]);
            printf("\n");
          }
        
          // Sort the elements of each bucket
          for (i = 0; i &lt; NBUCKET; ++i) {
            buckets[i] = InsertionSort(buckets[i]);
          }
        
          printf("-------------\n");
          printf("Bucktets after sorting\n");
          for (i = 0; i &lt; NBUCKET; i++) {
            printf("Bucket[%d]: ", i);
            printBuckets(buckets[i]);
            printf("\n");
          }
        
          // Put sorted elements on arr
          for (j = 0, i = 0; i &lt; NBUCKET; ++i) {
            struct Node *node;
            node = buckets[i];
            while (node) {
              arr[j++] = node->data;
              node = node->next;
            }
          }
        
          return;
        }
        
        // Function to sort the elements of each bucket
        struct Node *InsertionSort(struct Node *list) {
          struct Node *k, *nodeList;
          if (list == 0 || list->next == 0) {
            return list;
          }
        
          nodeList = list;
          k = list->next;
          nodeList->next = 0;
          while (k != 0) {
            struct Node *ptr;
            if (nodeList->data > k->data) {
              struct Node *tmp;
              tmp = k;
              k = k->next;
              tmp->next = nodeList;
              nodeList = tmp;
              continue;
            }
        
            for (ptr = nodeList; ptr->next != 0; ptr = ptr->next) {
              if (ptr->next->data > k->data)
                break;
            }
        
            if (ptr->next != 0) {
              struct Node *tmp;
              tmp = k;
              k = k->next;
              tmp->next = ptr->next;
              ptr->next = tmp;
              continue;
            } else {
              ptr->next = k;
              k = k->next;
              ptr->next->next = 0;
              continue;
            }
          }
          return nodeList;
        }
        
        int getBucketIndex(int value) {
          return value / INTERVAL;
        }
        
        void print(int ar[]) {
          int i;
          for (i = 0; i &lt; NARRAY; ++i) {
            printf("%d ", ar[i]);
          }
          printf("\n");
        }
        
        // Print buckets
        void printBuckets(struct Node *list) {
          struct Node *cur = list;
          while (cur) {
            printf("%d ", cur->data);
            cur = cur->next;
          }
        }
        
        // Driver code
        int main(void) {
          int array[NARRAY] = {42, 32, 33, 52, 37, 47, 51};
        
          printf("Initial array: ");
          print(array);
          printf("-------------\n");
        
          BucketSort(array);
          printf("-------------\n");
          printf("Sorted array: ");
          print(array);
          return 0;
}
</code>
<button  id="btn-copy9" onclick="copy('content-copy9')" class="btn" >copy</button> 
</pre>
</li>

            <li><b id="section10">Heap sort algorithm</b>
              <p class="detail">Heap sort processes the elements by creating the min-heap or max-heap using the elements of the given array. Min-heap or max-heap represents the ordering of array in which the root element represents the minimum or maximum element of the array.

                Heap sort basically recursively performs two main operations -
                
                Build a heap H, using the elements of array.
                Repeatedly delete the root element of the heap formed in 1st phase.
                Before knowing more about the heap sort, let's first see a brief description of Heap.</p>
                     <pre class="panda"><code id="content-copy10">      
// Heap Sort in C

 #include &lt;stdio.h&gt;
        
// Function to swap the the position of two elements
        void swap(int *a, int *b) {
            int temp = *a;
            *a = *b;
            *b = temp;
        }
        
        void heapify(int arr[], int n, int i) {
            // Find largest among root, left child and right child
            int largest = i;
            int left = 2 * i + 1;
            int right = 2 * i + 2;
        
            if (left &lt; n && arr[left] > arr[largest])
            largest = left;
        
            if (right &lt; n && arr[right] > arr[largest])
            largest = right;
        
            // Swap and continue heapifying if root is not largest
            if (largest != i) {
            swap(&arr[i], &arr[largest]);
            heapify(arr, n, largest);
            }
        }
        
        // Main function to do heap sort
        void heapSort(int arr[], int n) {
            // Build max heap
            for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);
        
            // Heap sort
            for (int i = n - 1; i >= 0; i--) {
            swap(&arr[0], &arr[i]);
        
            // Heapify root element to get highest element at root again
            heapify(arr, i, 0);
            }
        }
        
        // Print an array
        void printArray(int arr[], int n) {
            for (int i = 0; i &lt; n; ++i)
            printf("%d ", arr[i]);
            printf("\n");
        }
        
        // Driver code
        int main() {
            int arr[] = {1, 12, 9, 5, 6, 10};
            int n = sizeof(arr) / sizeof(arr[0]);
        
            heapSort(arr, n);
        
            printf("Sorted array is \n");
            printArray(arr, n);
    }
</code>
<button  id="btn-copy10" onclick="copy('content-copy10')" class="btn" >copy</button> 
</pre>
</li>



         <li><h4>STACK IN DATA STRUCTURE</h4><b id="section11">implementation of stack</b>
          <p class="detail">Stack is an abstract data type with a bounded(predefined) capacity. It is a simple data structure that allows adding and removing elements in a particular order. Every time an element is added, it goes on the top of the stack and the only element that can be removed is the element that is at the top of the stack, just like a pile of objects.</p>
                 <pre class="panda"><code id="content-copy11">
// Stack implementation in C

 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
                    
 #define MAX 10
                    
int count = 0;
                    
         // Creating a stack
         struct stack {
         int items[MAX];
         int top;
             };
         typedef struct stack st;
                    
         void createEmptyStack(st *s) {
         s->top = -1;
             }
                    
        // Check if the stack is full
        int isfull(st *s) {
        if (s->top == MAX - 1)
            return 1;
         else
            return 0;
         }
                    
        // Check if the stack is empty
        int isempty(st *s) {
        if (s->top == -1)
         return 1;
         else
        return 0;
        }
                    
        // Add elements into stack
        void push(st *s, int newitem) {
        if (isfull(s)) {
        printf("STACK FULL");
         }
          else {
             s->top++;
             s->items[s->top] = newitem;
             }
            count++;
        }
                    
        // Remove element from stack
        void pop(st *s) {
        if (isempty(s)) {
         printf("\n STACK EMPTY \n");
        }
         else {
            printf("Item popped= %d", s->items[s->top]);
            s->top--;
             }
            count--;
             printf("\n");
             }
                    
            // Print elements of stack
            void printStack(st *s) {
             printf("Stack: ");
                 for (int i = 0; i &lt; count; i++) {
                printf("%d ", s->items[i]);
                }
                printf("\n");
                }
                    
         // Driver code
            int main() {
            int ch;
            st *s = (st *)malloc(sizeof(st));
                    
                createEmptyStack(s);
                    
                 push(s, 1);
                 push(s, 2);
                 push(s, 3);
                 push(s, 4);
                    
                 printStack(s);
                    
                 pop(s);
                    
                printf("\nAfter popping out\n");
                printStack(s);
        }
                    
</code>
<button  id="btn-copy11" onclick="copy('content-copy11')" class="btn" >copy</button> 
</pre>
    </li> 
    


    <li><h4>QUEUE IN DATA STRUCTURE</h4><b id="section12">implementation of queue </b>
      <p class="detail">A queue in C is basically a linear data structure to store and manipulate the data elements. It follows the order of First In First Out (FIFO).

        In queues, the first element entered into the array is the first element to be removed from the array.</p>
        <pre class="panda"><code id="content-copy12">
// Queue implementation in C

#include &lt;stdio.h&gt;
#define SIZE 5

void enQueue(int);
void deQueue();
void display();

int items[SIZE], front = -1, rear = -1;

int main() {
  //deQueue is not possible on empty queue
  deQueue();

  //enQueue 5 elements
  enQueue(1);
  enQueue(2);
  enQueue(3);
  enQueue(4);
  enQueue(5);

  // 6th element can't be added to because the queue is full
  enQueue(6);

  display();

  //deQueue removes element entered first i.e. 1
  deQueue();

  //Now we have just 4 elements
  display();

  return 0;
}

void enQueue(int value) {
  if (rear == SIZE - 1)
    printf("\nQueue is Full!!");
  else {
    if (front == -1)
      front = 0;
    rear++;
    items[rear] = value;
    printf("\nInserted -> %d", value);
  }
}

void deQueue() {
  if (front == -1)
    printf("\nQueue is Empty!!");
  else {
    printf("\nDeleted : %d", items[front]);
    front++;
    if (front > rear)
      front = rear = -1;
  }
}

// Function to print the queue
void display() {
  if (rear == -1)
    printf("\nQueue is Empty!!!");
  else {
    int i;
    printf("\nQueue elements are:\n");
    for (i = front; i &lt;= rear; i++)
      printf("%d  ", items[i]);
  }
  printf("\n");
}
           
</code>
<button  id="btn-copy12" onclick="copy('content-copy12')" class="btn" >copy</button> </pre>
</li> 

 
 
<li><h4>LINKED LIST IN DATA STRUCTURE</h4><b id="section13">Implementaion of linked list</b>
  <p class="detail">A linked list is a sequence of data structures, which are connected together via links. Linked List is a sequence of links which contains items. Each link contains a connection to another link. Linked list is the second most-used data structure after array.</p>
    <pre class="panda"><code id="content-copy13">
// Linked list implementation in C

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
        
        // Creating a node
        struct node {
          int value;
          struct node *next;
        };
        
        // print the linked list value
        void printLinkedlist(struct node *p) {
          while (p != NULL) {
            printf("%d ", p->value);
            p = p->next;
          }
        }
        
        int main() {
          // Initialize nodes
          struct node *head;
          struct node *one = NULL;
          struct node *two = NULL;
          struct node *three = NULL;
        
          // Allocate memory
          one = malloc(sizeof(struct node));
          two = malloc(sizeof(struct node));
          three = malloc(sizeof(struct node));
        
          // Assign value values
          one->value = 1;
          two->value = 2;
          three->value = 3;
        
          // Connect nodes
          one->next = two;
          two->next = three;
          three->next = NULL;
        
          // printing node-value
          head = one;
          printLinkedlist(head);
        }
       
</code>
<button  id="btn-copy13" onclick="copy('content-copy13')" class="btn" >copy</button> 
</pre>
</li> 
        </ol>
</div>
</main><!--main container end-->

<footer><!--footer start-->
  &nbsp;&nbsp;&nbsp;&nbsp;
  <p>  &#169;  2022 CodeFinger</p>
  <div class="media">
      <span class="fb"> 
          <a href="##">
          <img src="./imges/media-img/fb.png" alt="Facebook" class="media-logo"></a> </span>
      <span class="git">
          <a href="##">
           <img src="./imges/media-img/git.png" alt="github" class="media-logo"> </a></span>
      <span class="linkedin"> 
          <a href="##">
          <img src="./imges/media-img/linkedin.png" alt="linkedin" class="media-logo"></a> </span>
      <span class="insta">
          <a href="##">
           <img src="./imges/media-img/insta.png" alt="instagram" class="media-logo"> </a></span>
  </div>
</footer>
 
  </body>
  <script src="./js-file/maincode.js"></script><!--script file link-->
 </html>